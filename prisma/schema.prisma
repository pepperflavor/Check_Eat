
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User{
  user_id Int @id @default(autoincrement())
  user_nick String // 닉네임
  user_allergy String? // 19가지 외 따로 입력받는 알러지
  user_allergy_en String? // 19가지 외 따로 입력받는 알러지
  user_allergy_ar String? // 19가지 외 따로 입력받는 알러지
  
  user_pro_img String @default("0") // 프로필 이미지 -> storage에서 받아옴, 지정 안하면 디폴트 0번으로 해둠
  user_is_halal Int @default(0) // 0: 할랄아님, 1: 할랄인 회원
  user_apple Int?  @default(0) // 0: 일반 회원, 1: 애플로그인

  user_vegan Int? // null: 비건아님, 이외에는 비건 단계
  vegan Vegan? @relation(fields: [user_vegan], references: [veg_id])

  // 다대다
  user_allergy_common CommonAl[] @relation("UserAllergyCommon") // 회원 가입시 입력받을때 "1,2,3,4,5" 숫자 스트링으로 받아올 예정 잘 갈라서 쓰셈
  
  LoginData LoginData[]

// 즐겨찾기 추가, 유저랑 1 :1
  favoriteStores FavoriteStore[] // 1:N 

  // 리뷰 관계 추가
  reviews Review[] // 1: 다
}

// 로그인용 데이터 따로 관리 한다면?
// 나이 정보를 따로 받아야 
model LoginData{
  ld_id Int @id @default(autoincrement())
  ld_usergrade Int // 0: 일반유저, 1: 업주
  ld_log_id String @unique // 로그인 아이디, 애플유조묜 apple sub값으로 저장
  ld_email String @unique // 이메일
  ld_pwd String? // 비밀번호
  ld_refresh_token String? // 리프레시 토큰
  ld_status Int @default(0) // 0: 활성화 되어있음, 1: 탈퇴 대기, 2: 회원 탈퇴함
  ld_lang String @default("ko") // 유저가 사용하는 언어 - 소문자, ko / en / ar

  ld_user_id Int? // 유저 테이블에 저장되어있는 id 인덱스
  user User? @relation(fields: [ld_user_id], references: [user_id])

  ld_sajang_id Int? // 사장 테이블에 저장되어있는 id 인덱스
  sajang Sajang? @relation(fields: [ld_sajang_id], references: [sa_id])

  IdentityVerification IdentityVerification?
}

model Sajang{
  sa_id Int @id @default(autoincrement())
  sa_phone String // 사장님 연락처
  // sa_img String? // 가게 이미지 - storage에서 받아와야 함, 지정안하면 기본 이미지
  sa_certification Int? // 0: 인증 대기 중 || 회원가입 진행중, 1: 사업자 인증 받음, 2: 인증 재시도 필요함
  sa_certi_status Int @default(0) // 0: 인증 대기중, 1: 인증 완료, 2: 인증 실패 - 유저가 데이터 잘못입력함, 3: 서버문제로 실패 -> 내부적으로 재 인증해줘야 함

  foods Food[] // 1:N 관계
  loginData LoginData[] // Opposite relation field for LoginData model

  Store Store[] @relation("SajangStore") // 사장이 가게 여러개 가질 수 있다고 함 수정필요


  businessCertis BusinessCerti[]
}

model BusinessCerti{
  bs_id Int @id @default(autoincrement())
  bs_no String @unique // 사업자 등록증 번호
  bs_name String // 업체명
  bs_type String // 업태
  bs_address String // 주소

  bs_sa_id Int
  sajang   Sajang @relation(fields: [bs_sa_id], references: [sa_id], onDelete: Cascade, onUpdate: Cascade)

  stores   Store[]

  @@index([bs_sa_id])
}

// 다른 언어는 테이블을 나누는게 맞다고하심
model Food {
  foo_id Int @id @default(autoincrement())
  foo_name String? // 음식이름
  foo_material String[] // 재료
  foo_price Int // 가격
  foo_img String? // 음식 이미지 - storage에서 받아와야 함, 할랄 음식이라면 할랄 테이블에서 받아옴
  foo_status Int @default(0) // 0: 정상판매중, 1: 사장 요청으로 판매 일시중지, 2: 삭제된 음식
  
  foo_sa_id Int // 업주 사장아이디
  Sajang Sajang @relation(fields: [foo_sa_id], references: [sa_id])
  
  foo_vegan Int? // 비건 단계,  1: 비건단계1, 2: 비건단계2, 3: 비건단계3
  foo_vegan_data Vegan? @relation(fields: [foo_vegan], references: [veg_id])

  // 알러지 다대다
  CommonAl CommonAl[] @relation("CommonAlFood")
  Store Store[]

  // 음식과 다대다 관계
  review Review[] @relation("ReviewFoods") 

  // 음식 번역
  food_translate_en FoodTranslateEN?
  food_translate_ar FoodTranslateAR?
}

model FoodTranslateEN{
  ft_id Int @id @default(autoincrement())
  ft_en_name String? // 음식 이름 영어
  ft_en_mt String[] @default([]) // 재료 영어
  ft_en_price String? // 가격 영어

  food_id Int @unique
  food Food @relation(fields: [food_id], references: [foo_id])
}

model FoodTranslateAR{
  ft_ar_id Int @id @default(autoincrement())
  ft_ar_name String? // 아랍어 이름
  ft_ar_mt String[] @default([])// 재료 아랍어
  ft_ar_price String? // 가격 아랍어

  food_id Int   @unique
  food    Food  @relation(fields: [food_id], references: [foo_id])
}

model Holiday{
  holi_id Int @id @default(autoincrement())
  holi_weekday Int // 요일, 0: 일요일, 1:월요일 ...
  holi_break String // 브레이크 타임
  holi_runtime_sun String? // 일요일 영업시간
  holi_runtime_mon String? // 월요일 영업시간... 이런식으로 요일별 컬럼 추가하기
  holi_runtime_tue String? // 화요일 영업시간  
  holi_runtime_wed String? // 수요일 영업시간
  holi_runtime_thu String? // 목요일 영업시간
  holi_runtime_fri String? // 금요일 영업시간
  holi_runtime_sat String? // 토요일 영업시간
  
  holi_regular String? // 정기 휴일
  holi_public String? // 한국 공휴일들 중에 쉬는날

  holi_sajang_id Int
  // sajang Sajang @relation(fields: [holi_sajang_id], references: [sa_id])

  store_id      Int     @unique
  store         Store   @relation(fields: [store_id], references: [sto_id])
}

// 19가지 보편적인 알러지
// 이건 순서 고정으로 갈 예정
model CommonAl{
  coal_id Int @id @default(autoincrement())
  coal_name String @unique// 알러지 원료이름
  // coal_img String // 알러지 원료 이미지 -> storage에 저장할 예정

  food Food[] @relation("CommonAlFood")

  // 알러지 여러개 선택할 수 있음 , 다대다₩
  user User[] @relation("UserAllergyCommon")
}

model Vegan{
  veg_id Int @id @default(autoincrement())
  veg_name String @unique// 비건 단계 이름
  // veg_img String? // 비건 단계 이미지는 내장으로 함

  food Food[] // 음식과 다대다 관계
  user User[] // 유저와 1:1 
}

// 리뷰 테이블 추가 해야함
// ocr 가능하면 넣어보기
// 사장님 마이 페이지에 최신 리뷰 하나 꺼내줘야함
model Review{
  revi_id Int @id @default(autoincrement())

  revi_reco_step Int // 추천 단계 0: 추천함, 1: 보통, 2: 추천안함-이때는 텍스트 필수/ -1 :나중에 쓰기
  revi_reco_vegan Int? // 추천하는 비건 단계
  revi_content String? // 추천/ 추천안했을 때 텍스트 옵셔널
  revi_status Int @default(0) // 0 : 리뷰 썼음, 1: 나중에 쓰려고 보류 중
  revi_edit Int @default(0) // 리뷰 수정횟수
  revi_create DateTime @default(now())

  foods Food[] @relation("ReviewFoods") // 음식과 다대다 관계

  // N:1 - 하나의 유저가 여러 리뷰
  user_id        Int
  user           User      @relation(fields: [user_id], references: [user_id])

  // N:1 - 하나의 가게에 여러 리뷰
  store_id       Int
  store          Store     @relation(fields: [store_id], references: [sto_id])

  review_translate_en ReviewTranslateEN?
  review_translate_ar ReviewTranslateAR?

  ReviewImage ReviewImage[]
}

model ReviewImage {
  revi_img_id Int @id @default(autoincrement())
  revi_img_url String
  review_id Int
  review Review @relation(fields: [review_id], references: [revi_id])
}

// 리뷰 번역은 테이블을 따로 나누는게 낫다고 하심
model ReviewTranslateEN{
  rt_en_id Int @id @default(autoincrement())
  rt_content_en String // 리뷰 내용 영어

  revi_id Int   @unique
  review  Review @relation(fields: [revi_id], references: [revi_id])
}

model ReviewTranslateAR{
  rt_ar_id Int @id @default(autoincrement())
  rt_ar_content String // 아랍어로 번역한 리뷰
  

  revi_id Int   @unique
  review  Review @relation(fields: [revi_id], references: [revi_id])
}

model Store{
  sto_id Int @id @default(autoincrement())
  sto_name String // 가게 이름
  sto_name_en String // 가게이름 사장이 선택적으로 영어명으로 입력, 이제 필수값
  sto_img String? // 가게 이미지 - storage에서 받아와야 함, 지정안하면 기본 이미지
  sto_address String // 가게 주소
  sto_phone String? // 가게 전화번호
  sto_status Int @default(0) // 0: 정상영업, 1: 임시 휴업/휴가, 2: 가게접음
  sto_halal Int @default(0)// 0: 할랄 인증 x, 1: 할랄 인증 받은 가게
  sto_type String? // 업종 지금은 일단, 음식점 / 카페
  sto_latitude Float // 위도
  sto_longitude Float // 경도 -> 프론트에서 처리해서 줄거임~

  sto_sa_id Int
  sajang Sajang @relation("SajangStore", fields: [sto_sa_id], references: [sa_id])

  holiday Holiday?

  Food Food[]
  favoriteUsers FavoriteStore[] // 1:N 

  // 리뷰 관계
  review Review[] // 1:n 가게 리뷰


  // 사업자 등록증이랑  다대 1 관계
  sto_bs_id     Int? // 필수로 하려면 Int 로
  businessCerti BusinessCerti? @relation(fields: [sto_bs_id], references: [bs_id], onDelete: SetNull, onUpdate: Cascade)

  //같은 데이터로 요청들어오면 중복 차단 처리
  @@unique([sto_sa_id, sto_bs_id, sto_name, sto_latitude, sto_longitude], name: "uniq_store_owner_cert_name_geo")
  @@index([sto_bs_id])
}

// 즐겨찾기 한 가게
model FavoriteStore {
  id          Int      @id @default(autoincrement())
  
  user        User     @relation(fields: [user_id], references: [user_id])
  user_id     Int

  store       Store    @relation(fields: [sto_id], references: [sto_id])
  sto_id      Int

  added_at    DateTime @default(now()) // 즐겨찾기 등록 시간
  order_index Int?                // 사용자가 재정렬한 순서 저장 가능

  @@unique([user_id, sto_id])     // 같은 가게 중복 즐겨찾기 방지
}

model FoodMeterialSeed{
  foo_seed_id          Int      @id @default(autoincrement())
  foo_seed_name        String   // 음식 이름 (RCP_NM)
  foo_seed_ingredients String[] // 재료 목록 (RCP_PARTS_DTLS 분리 후 저장)
}



// 본인인증 관련..
model IdentityVerification {
  // PortOne에 보낸 identityVerificationId(상점이 생성)
  iv_id              String   @id
  iv_status          String   // READY | VERIFIED | FAILED
  iv_method          String?  // SMS | APP
  iv_operator        String?  // SKT | KT | LGT | MVNO

  // 결과(필요한 것만)
  iv_name            String?
  iv_phoneNumber     String?  @db.VarChar(20)
  iv_birthDate       DateTime? @db.Date
  iv_gender          String?  // "M" | "F" 등
  iv_ci              String?  @db.Text // 필요할 때만
  iv_di              String?  @db.Text // 필요할 때만
  iv_verifiedAt      DateTime?
  iv_payload         Json?    // 원본 응답 일부(진짜 필요한 경우에만 저장)

  // 가입 전 임시 연결 키(앱에서 들고 다님, 1회성/짧은 TTL)
  iv_pre_signup_key  String?  @unique

  // 가입 후 연결 (아래 중 하나만 채우는 1:1 구조 권장)
  login_data_id   Int?     @unique
  loginData       LoginData? @relation(fields: [login_data_id], references: [ld_id])

  // sajang_id       Int?     @unique
  // sajang          Sajang?    @relation(fields: [sajang_id], references: [sa_id])

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([iv_phoneNumber])
}

